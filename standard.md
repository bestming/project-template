## Java后端

 【强制】表必备三字段：id, create_time, update_time。 



9.【强制】POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。

POJO 类中的变量，不要以大写开头。否则序列化可能失败。



19.【参考】各层命名规约：

A) Service/DAO 层方法命名规约

1） 获取单个对象的方法用 get 做前缀。

2） 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。

3） 获取统计值的方法用 count 做前缀。

4） 插入的方法用 save/insert 做前缀。

5） 删除的方法用 remove/delete 做前缀。

6） 修改的方法用 update 做前缀。

B) 领域模型命名规约

1） 数据对象：xxxDO，xxx 即为数据表名。

2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。

3） 展示对象：xxxVO，xxx 一般为网页名称。

4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。



6【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。

正例："test".equals(object);

反例：object.equals("test");

说明：推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b)



1） 【强制】所有的 POJO 类属性必须使用**包装数据类型。**

2） 【强制】RPC 方法的返回值和参数必须使用**包装数据类型。**



14.【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。



6.【强制】使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行添

加元素操作，否则会抛出 UnsupportedOperationException 异常。(List集合同理)



17.【推荐】集合初始化时，指定集合初始值大小。



7【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。



5.【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。

说明：因为 String 字符串的拼接会使用 StringBuilder 的 append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。



【参考】分层领域模型规约：

DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。

BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。

Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类

来传输。

VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。



3.【推荐】给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM场景时输出 dump 信息。



**4、依赖注入的注解**

如无特殊情况，依赖注入**优先**使用 @Resource 注解，不要使用 @AutoWired。

**6、Lombok 的使用**

**不建议**直接使用 lombok 的 @Data 注解，建议按需使用 @Getter 和 @Setter 注解。因为其生成的 equals() 、hashCode()、toString() 方法过于臃肿，我们一般用不到。即使需要用到，一般也不会基于所有的属性进行 equals() 、hashCode()。

13、微服务依赖关系

1. 如果**不需要**被其他服务调用的 类 或 接口，不要放在 **xxx-api** 里面，而应该放在 **xxx-service**，减少外部暴露，其他服务也可以少加载一些不必要的类文件。
2. 后端可以通过引入 **xxx-api** 引入其他服务的实体类，但是后台多是查询统计类的请求，尽量不要远程调用，直接在本地新建对应的 Service 和 Dao 即可，而且 admin 的 Service 层可以不设计接口。

## 数据库

1. 设计表时，需要考虑数据量是否能适应业务的增长规模，并考虑是否需要分库分表（以及历史记录表）。如需分表，则主键ID采用雪花算法。否则使用数据库的ID自增即可。**不可**使用 UUID 作为主键。
2. 业务上关联其他表主键ID的列，命名也要以"_id" 结尾。
3. 数据库中的注释要和代码中的注释及时保持同步，对于同一个字段不同业务值的解释，请统一采用 val1=desc1；val2=desc2；val3=desc3 （间隔符是中文的分号+空格）的格式，例如：status 的注释为"启用状态：1=启用；0=停用"。
4. 对于整数类型的列，请尽量选择**较小**的数据类型，但限定范围为：tinyint、int、bigint（主键列至少要是int类型，也可统一为 bigint ），Java代码中只能是 Integer 和 Long 两种类型之一。
5. 非负数列，应尽量标记为非负数（unsigned），以便尽早发现业务代码中的 bug。
6. 根据墨菲定律，如果几个字段在业务上可以唯一确定所在行，应当加唯一索引。
7. 表名和字段名称全小写。
8. 定长文本，优先采用**char**类型；非定长文本一般使用**varchar**类型。字符集必须是**utf8mb4**，排序规则必须是**utf8mb4_0900_ai_ci**。（数据库已统一为该设置，直接默认即可）。
9. 数据列尽量NOT NULL，**varchar**一般默认为""，整数列视具体情况而定（如果业务上允许为 null 的，那就允许该字段为 NULL）。
10. 对于状态列：如果只存在互斥状态，例如 **是或否、启用或停用** 的，统一用**1或0**表示。 存在多种状态的，一般用 0 表示默认值，正数表示积极状态，负数表示消极状态。对立的业务状态，最好数值相同，符号相反。 业务状态尚未完全稳定、有一定变动风险的的，建议采用 10 的整数倍值，以预留扩展空间。 
11. 时间列，如无特殊需求，一般使用 datetime(3) 类型（需保存毫秒值），字段一般以 xxx_time 命名。**添加时间**列统一为"add_time"，最后更新时间为 "update_time"。只需要精确到日期的，可以采用 date 类型，以 xxx_date 命名字段。

## 前端

URL 路径不能使用大写，单词如果需要分隔，统一使用下划线。

3） 请求方法：对具体操作的定义，常见的请求方法如下：

a） GET：从服务器取出资源。

b） POST：在服务器新建一个资源。

c） PUT：在服务器更新资源。

d） DELETE：从服务器删除资源。

4） 请求内容：URL 带的参数必须无敏



【强制】前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}。



【强制】在前后端交互的JSON格式数据中，所有的key必须为小写字母开始的lowerCamelCase风格，符合英文表达习惯，且表意完整。



【强制】对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用Long 类型。



7【强制】HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。



【强制】在翻页场景中，用户输入参数的小于1，则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。



- 明确空值的意义。比如在做更新操作时，空值是表示重置，还是忽略更新